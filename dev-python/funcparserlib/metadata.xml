<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pkgmetadata SYSTEM "http://www.gentoo.org/dtd/metadata.dtd">
<pkgmetadata>
	<maintainer>
		<email>jnrowe@gmail.com</email>
		<name>James Rowe</name>
	</maintainer>
	<longdescription lang="en">
		Parser combinators are just higher-order functions that take parsers as
		their arguments and return them as result values. Parser combinators
		are:
		
		* First-class values
		* Extremely composable
		* Tend to make the code quite compact
		* Resemble the readable notation of xBNF grammars

		Parsers made with funcparserlib are pure-Python LL(*) parsers. It means
		that it's very easy to write them without thinking about look-aheads and
		all that hardcore parsing stuff. But the recursive descent parsing is
		a rather slow method compared to LL(k) or LR(k) algorithms.

		So the primary domain for funcparserlib is parsing little languages or
		external DSLs (domain specific languages).

		The library itself is very small. Its source code is only 0.5 KLOC, with
		lots of comments included. It features the longest parsed prefix error
		reporting, as well as a tiny lexer generator for token position
		tracking.
	</longdescription>
	<upstream>
		<doc lang="en">http://archlinux.folding-maps.org/2009/funcparserlib/Tutorial</doc>
		<remote-id type="google-code">funcparserlib</remote-id>
		<changelog>http://archlinux.folding-maps.org/2009/funcparserlib/Changes</changelog>
		<bugs-to>http://code.google.com/p/funcparserlib/issues/list</bugs-to>
	</upstream>
</pkgmetadata>
